#!/usr/bin/env ruby

# FIXME: this should be in services/wolfram
require 'wolfram'

require 'rubygems'
if not require 'bundler/setup' then
  $stderr.puts "Please install the bundler gem to proceed."
  exit(1)
end

# Requirements for actual running
require 'yaml'
require 'timeout'
require './lib/persistent_hash.rb'
require './lib/multilog.rb'
require './lib/hook_bot.rb'
require './lib/hook_service.rb'

# =====================
# Constants, that is, true ones, not fron the config filke
#
# Don't reconnect faster than this
# This overrides the value of config[:bot_connection_poll_rate]
# to ensure we don't mash servers
MIN_RECONNECT_RATE = 60

# The time to give the bot to quit IRC
# when handed a signal
BOT_DC_TIMEOUT = 5

# The logging level to use when loading log configs
BOOTSTRAP_LOG_LEVEL = Logger::DEBUG


# =====================
# Load into a persistent object so we can save later
config_file   = ARGV[0] || "config/config.yml"
config        = PersistentHash.new(config_file, true)
$log          = MultiOutputLogger.new({:level => BOOTSTRAP_LOG_LEVEL}, config[:logging][:progname])

# =====================
# Configure environment system
#
if(config[:environment])
  if not config[:modes][config[:environment]].is_a? Hash then
    $log.fatal "Invalid environment: #{config[:environment]}!"
    exit(1)
  end

  $log.info "Starting in #{config[:environment]} mode..."
  overrides = 0
  recursive_merge = lambda{|default, override|
      # if the thing to override is not a hash, don't probe further
      return override if not override.is_a? Hash

      # pre-log, but warn the user
      $log.warn "WARNING: Overriding environment config that does not exist." if not default

      # Each override, overwrite default value
      override.each{|k, v|
        default[k] = recursive_merge.call(default[k], v)
        overrides += 1
      }

      # Send the overridden values back
      return default
    }

  # Merge configs
  config = recursive_merge.call(config, config[:modes][config[:environment]])
  $log.info "Done (changed #{overrides} configs)."
end


# =====================
# Then, create global log
$log.info "Bootstrapping logs..."
logdevs = []
config[:logging][:logs].each{|name, ldopts| 
  # Construct the log
  ld            = {:name => name}
  ld[:dev]      = %w{STDOUT STDERR}.include?(ldopts[:dev]) ? eval(ldopts[:dev]) : ldopts[:dev] || STDOUT
  ld[:level]    = ldopts[:level]

  # Add to the list of logs
  logdevs << ld
}
# Remove log used during the bootstrap
# then add the new ones and report
$log.remove_log(:default)
$log.configure_logs(logdevs)  
$log.summarise_logging





# =====================
# Handle signals nicely.
$log.debug "Installing signal handlers."
%w{INT HUP KILL ABRT}.each{|s|
  trap(s) { raise SignalException.new(s) }
}



# ----------------------------------------
# Constuct hooks

# Ensure our namespace covers the hooks dir
Dir.glob(File.join(File.dirname(__FILE__), config[:hooks][:dir], "*.rb")).each{|x| 
  load x
}



# ----------------------------------------
# Instantiate the bot
bot = HookBot.new(config[:irc])
config[:hooks][:objs].each{|h|
  
  # Create the hook object with a reference to the bot
  hook = eval("#{h}.new(bot)")
  hook.hook_thyself

  # Check it makes sense to use callbacks on it
  raise "Hook #{h} is not a subclass of HookService!" if not hook.is_a? HookService
}


# -----------------------------------------------------------------------------------
# Start execution proper
begin

  # Continually connect and run
  loop{
    $log.info "Connecting bot!"
    bot.run(true, true)
    $log.info "Bot connected --- dropping back to check connection"

    while(bot.connected?)
      sleep([config[:bot_connection_poll_rate], MIN_RECONNECT_RATE].max)
    end
    $log.error "Disconnected!"
  }

# Handle signals nicely.
rescue SignalException => Se
  $log.fatal "Caught signal!"
  if defined? bot and bot.connected? then
    $log.fatal "Disconnecting bot... (Will wait #{BOT_DC_TIMEOUT}s)"
    begin
      Timeout::timeout(BOT_DC_TIMEOUT){
        bot.disconnect("Caught signal.")
      }
    rescue Timeout::Error => TMe
    end
    $log.fatal "Done."
  end
end



#!/usr/bin/env ruby

# -----------------------------------------------------------------------------------
# Initial checks
require 'rubygems'
if RUBY_VERSION < "1.9.3" then
  $stderr.puts "This bot requires ruby >= 1.9.3"
  exit(1)
end

if not require 'bundler/setup' then
  $stderr.puts "Please install the bundler gem to proceed."
  exit(1)
end

# -----------------------------------------------------------------------------------
# Requirements for actual running
require 'yaml'
require 'timeout'
require './lib/persistent_hash.rb'
require './lib/multilog.rb'
require './lib/hook_bot.rb'
require './lib/hook_service.rb'

# -----------------------------------------------------------------------------------
# Constants, that is, true ones, not fron the config filke
#
# Bot version
VERSION = '0.2.1'
#
#
# Don't reconnect faster than this
# This overrides the value of config[:bot_connection_poll_rate]
# to ensure we don't mash servers
MIN_RECONNECT_RATE = 60

# The time to give the bot to quit IRC
# when handed a signal
BOT_DC_TIMEOUT = 5

# The logging level to use when loading log configs
BOOTSTRAP_LOG_LEVEL = Logger::INFO

CONFIG_FILE = 'config/config.yml'

# -----------------------------------------------------------------------------------
# Load into a persistent object so we can save later
environment   = ARGV[0] 
config        = PersistentHash.new(CONFIG_FILE, true)
$log          = MultiOutputLogger.new({:level => BOOTSTRAP_LOG_LEVEL}, config[:logging][:progname])
$log.info "LUGod v#{VERSION} starting..."

# -----------------------------------------------------------------------------------
# Configure environment system
#
if(environment)
  environment = environment.to_sym
  if not config[:environments][environment].is_a? Hash then
    $log.fatal "Invalid environment: #{environment}!"
    $log.info "Available environments: #{config[:environments].keys.join(", ")}"
    exit(1)
  end

  $log.info "Using #{environment} environment..."
  overrides = 0
  recursive_merge = lambda{|default, override|
      # if the thing to override is not a hash, don't probe further
      return override if not override.is_a? Hash

      # pre-log, but warn the user
      $log.warn "WARNING: Overriding environment config that does not exist." if not default

      # Each override, overwrite default value
      override.each{|k, v|
        default[k] = recursive_merge.call(default[k], v)
        overrides += 1
      }

      # Send the overridden values back
      return default
    }

  # Merge configs
  config = recursive_merge.call(config, config[:environments][environment])
  $log.info "Done (changed #{overrides} configs)."
end


# -----------------------------------------------------------------------------------
# Then, create global log
$log.info "Bootstrapping logs..."
logdevs = []
config[:logging][:logs].each{|name, ldopts| 
  # Construct the log
  ld            = {:name => name}
  ld[:dev]      = %w{STDOUT STDERR}.include?(ldopts[:dev]) ? eval(ldopts[:dev]) : ldopts[:dev] || STDOUT
  ld[:level]    = ldopts[:level]

  # Add to the list of logs
  logdevs << ld
}
# Remove log used during the bootstrap
# then add the new ones and report
$log.remove_log(:default)
$log.configure_logs(logdevs)  
$log.summarise_logging





# -----------------------------------------------------------------------------------
# Handle signals nicely.
$log.debug "Installing signal handlers."
%w{INT HUP KILL ABRT}.each{|s|
  trap(s) { raise SignalException.new(s) }
}



# -----------------------------------------------------------------------------------
# Constuct hooks
def camel_to_underscore(str)
  # First, isolate numbers, then break by case, then merge double-underscores again
  return str.gsub(/([0-9]+)/, '_\1_').gsub(/([A-Z0-9]+[a-z])/, '_\1\2').gsub('__', '_').gsub(/^_/, '').downcase
end

# Ensure our namespace covers the hooks dir
config[:hooks][:objs].each{|h|
  # Construct path from class name
  file = camel_to_underscore(h) + ".rb"
  path = File.join(config[:hooks][:dir], file)
  $log.info "Loading service #{h} from #{file}..."

  # Check the file exists for the user
  if not File.exist?(path) then
    $log.fatal "No file found for module: #{h}"
    $log.fatal "Please check #{path} exists."
    exit(1)
  end

  # Load file
  load path
}


# -----------------------------------------------------------------------------------
# Instantiate the bot
hook_manager  = HookBot::HookManager.new
bot           = HookBot::Bot.new(config[:irc], hook_manager)
services      = []
config[:hooks][:objs].each{|h|
  
  # Create the hook object with a reference to the bot
  $log.info "Registering hooks for #{h}..."
  hook_config   = PersistentHash.new( File.join(config[:hooks][:config_dir], "#{h}.yml"), true ) 
   
  # Load required gems
  if(hook_config[:gems].is_a? Array) then
    hook_config[:gems].each{|gem|
      require gem
    }
  end

  hook = eval("#{h}.new(hook_manager, hook_config)")
  hook.hook_thyself
  services << hook

  # Check it makes sense to use callbacks on it
  raise "Hook #{h} is not a subclass of HookService!" if not hook.is_a? HookService
}


# -----------------------------------------------------------------------------------
# Start execution proper
# Daemonize if we want to
if config[:daemonise] then
  $log.info "Forking to background..."
  Process.daemon(true)
end

# -----------------------------------------------------------------------------------
# Then connect
begin

  # Continually connect and run
  loop{
    $log.info "Connecting bot..."
    bot.run(true, true)
    $log.info "Bot connected --- dropping back to check connection"

    while(bot.connected?)
      sleep([config[:bot_connection_poll_rate], MIN_RECONNECT_RATE].max)
    end
    $log.error "Disconnected!"
  }

# Handle signals nicely.
rescue SignalException => Se
  $log.fatal "Caught signal!"
  if defined? bot and bot.connected? then

    # Close all services once and for all.
    services.each{|s|
      $log.fatal "Closing Service #{s.class}..."
      s.close
    }
    
    # Unhook any that didn't unhook themself
    $log.fatal "Unhooking remaining services..."
    hook_manager.unregister_all
   
    # Then d/c bot
    $log.fatal "Disconnecting bot... (Will wait #{BOT_DC_TIMEOUT}s)"
    begin
      Timeout::timeout(BOT_DC_TIMEOUT){
        bot.disconnect("Caught signal.")
      }
    rescue Timeout::Error => TMe
    end
    $log.fatal "Done."
  end
end

$log.info "Goodbye!"
exit(0)
